# Events consumer service

This service listens for events generated by the events mock service.
It listens for messages via subscribing to Redis channel and then processes the event and stores data into SQLite Db.

The service consists of several modules:
- `config` to define configuration object of the app, acts like a Singleton, holds Redis/DB connections, control channel object and shutdown flag.
- `consumer` is responsible for reading events from a Redis channel and passing then onto the `engine`
- `engine` is the main computing module of the service that processes the incoming events, runs necessary  calculations(currency conversion), selects suitable competitions and filters out competitions that don't match to this event, and stores bets for them as well as storing the original event
- `handlers` provides HTTP handlers for the Web API of the service
- `redis` provides the Redis client connected to the server
- `sqlite` is the module to do everything with the DB, it has functions to create necessary tables as well for adding records to them, all DB communication is done via this module

At boot, the application initializes connections to Redis & SQLite, creates necessary tables and indices(if not already) and starts HTTP server as well as a goroutine for the OS signal processing.

Once signal is received(`syscall.SIGINT` or `syscall.SIGTERM`), a message is sent to a channel and shutdown flag is set to True, then Redis consumer gets stopped and after 2 seconds, the HTTP server gets stopped too.

## How to run
Open a terminal tab
```
> go build main.go && ./main
```
The service will log the startup logs

## How to create a competition

```curl
curl --location 'localhost:8080/competitions' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'start_at=1747523554' \
--data-urlencode 'end_at=1747566761' \
--data-urlencode 'rules=event_type==bet ? amount : 0'
```

```
 curl --location 'localhost:8080/competitions' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'start_at=1747662986' \
--data-urlencode 'end_at=1747734991' \
--data-urlencode 'rules=studio=="StudioY" ? amount : 0'
```

Once a competition is created via the API, it gets picked up by the engine and is taken into consideration for all the incoming events without the need of restarting the service.

## DB schema

```SQL
sqlite> .schema users
CREATE TABLE users (
				id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
				user_id INTEGER NOT NULL
		);
CREATE UNIQUE INDEX users_idx on users  (user_id);


sqlite> .schema bets
CREATE TABLE bets (
			id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
			user_id INTEGER NOT NULL,
			amount REAL NOT NULL,
			competition_id INTEGER NOT NULL
    );
CREATE INDEX bets_idx on bets (competition_id);


sqlite> .schema events
CREATE TABLE events (
			id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
			event_type TEXT NOT NULL,
			user_id INTEGER NOT NULL,
			amount REAL NOT NULL,
			currency TEXT NOT NULL,
			exchange_rate REAL NOT NULL,
			game TEXT NOT NULL,
			distributor TEXT NOT NULL,
			studio TEXT NOT NULL,
			timestamp INTEGER NOT NULL
		);


sqlite> .schema competitions
CREATE TABLE competitions (
        id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
		start_at INTEGER NOT NULL,
		end_at INTEGER NOT NULL,
		rules TEXT
    );
```


## Notes:
During the testing I discovered an issue with it in a situation when there are no events incoming from the mock server. Because there is no processing of the events, the Competitions channel(`config.AppConfig.CompsChannel`) doesn't get read so the HTTP handler gets blocked. To mitigate that I decided to make that channel buffered with 100 elements for the time being but generally this requires some refactoring.


